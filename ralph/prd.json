{
  "project": "subq",
  "description": "Weight tracking application with Effect-based API and React frontend",
  "version": "1.0.0",
  "created_at": "2026-01-14",
  "updated_at": "2026-01-14",
  "technology": {
    "language": "TypeScript",
    "runtime": "Bun",
    "backend": {
      "framework": "Effect HttpApi",
      "database": "SQLite (drizzle-orm, @effect/sql-sqlite-bun)",
      "auth": "better-auth"
    },
    "frontend": {
      "framework": "React 19",
      "routing": "TanStack Router",
      "state": "Effect Atom (@effect-atom/atom-react)",
      "styling": "Tailwind CSS v4"
    },
    "testing": {
      "unit": "bun test (@codeforbreakfast/bun-test-effect)",
      "e2e": "Playwright"
    }
  },
  "reference_repos": [
    "https://github.com/Effect-TS/effect",
    "https://github.com/TanStack/router",
    "https://github.com/tim-smart/effect-atom"
  ],
  "specs_dir": "specs/",
  "available_specs": [
    {
      "file": "EFFECT_SQL.md",
      "description": "Schema-based SQL, SqlSchema helpers, transactions, Model.Class"
    },
    {
      "file": "EFFECT_BEST_PRACTICES.md",
      "description": "Core Effect rules: no any, TaggedErrors, Schema patterns, equality"
    }
  ],
  "testing_policy": {
    "mandatory": "EVERY story MUST include tests. A story is NOT complete without passing tests.",
    "verification": "bun run check && bun run test:all",
    "no_exceptions": "Do NOT mark a story as complete if tests are missing or failing."
  },
  "stories": [
    {
      "id": "SQL-1.0",
      "phase": "SQL Safety",
      "epic": "Eliminate unsafe queries",
      "title": "Replace unsafe dynamic UPDATE in goal-repo",
      "description": "The goal-repo.ts update function uses sql.unsafe() with string concatenation (line 206), creating SQL injection risk. Refactor to use parameterized queries. Build the UPDATE statement with sql template literals and proper placeholders instead of string interpolation.",
      "specs": [
        "EFFECT_SQL.md"
      ],
      "acceptance_criteria": [
        "packages/api/src/goals/goal-repo.ts has no .unsafe() calls",
        "rg '\\.unsafe\\(' packages/api/ returns 0 matches",
        "Update uses parameterized sql template literals",
        "bun run test:api passes (goal tests)",
        "Manual test: update goal with apostrophe in notes field works"
      ],
      "technical_details": {
        "files": [
          "packages/api/src/goals/goal-repo.ts"
        ],
        "pattern": "Use sql`UPDATE ... SET column = ${value}` instead of string concatenation. May need multiple SET clauses or conditional logic.",
        "current_issue": "Line 182-206: builds updates array with string interpolation, then uses sql.unsafe()"
      },
      "status": "complete",
      "estimated_complexity": "medium"
    },
    {
      "id": "SQL-1.1",
      "phase": "SQL Safety",
      "epic": "Remove type assertions",
      "title": "Fix settings-repo type assertion",
      "description": "settings-repo.ts line 85 uses 'as { weight_unit: string; reminders_enabled: number }' type assertion. Replace with Schema.Struct decoding for the existing row check.",
      "specs": [
        "EFFECT_SQL.md",
        "EFFECT_BEST_PRACTICES.md"
      ],
      "acceptance_criteria": [
        "packages/api/src/settings/settings-repo.ts has no 'as {' type assertions",
        "Uses Schema.Struct for decoding the SELECT result",
        "bun run test:api passes (settings tests)",
        "bun run typecheck passes"
      ],
      "technical_details": {
        "files": [
          "packages/api/src/settings/settings-repo.ts"
        ],
        "pattern": "Define CurrentSettingsRow = Schema.Struct({ weight_unit: Schema.String, reminders_enabled: Schema.Number }), use Schema.decodeUnknown",
        "current_issue": "Line 85: existing[0] as { weight_unit: string; reminders_enabled: number }"
      },
      "status": "pending",
      "estimated_complexity": "small"
    },
    {
      "id": "SQL-1.2",
      "phase": "SQL Safety",
      "epic": "Remove type assertions",
      "title": "Fix injection-log-repo generic types",
      "description": "injection-log-repo.ts uses sql<{ drug: string }> and sql<{ injection_site: string }> generic types instead of Schema validation. Replace with Schema.Struct decoding for type safety and runtime validation.",
      "specs": [
        "EFFECT_SQL.md"
      ],
      "acceptance_criteria": [
        "getUniqueDrugs uses Schema.Struct for result decoding",
        "getUniqueSites uses Schema.Struct for result decoding",
        "getLastSite uses Schema.Struct for result decoding",
        "No sql<T> generic type annotations remain in injection-log-repo.ts",
        "bun run test:api passes"
      ],
      "technical_details": {
        "files": [
          "packages/api/src/injection/injection-log-repo.ts"
        ],
        "pattern": "Define DrugRow = Schema.Struct({ drug: Schema.String }), decode with Schema.decodeUnknown(Schema.Array(DrugRow))",
        "current_issue": "Lines 228, 236, 247: sql<{...}> without runtime validation"
      },
      "status": "pending",
      "estimated_complexity": "small"
    },
    {
      "id": "SQL-2.0",
      "phase": "Error Handling",
      "epic": "Proper Option handling",
      "title": "Replace Option.getOrThrow in goal-repo",
      "description": "goal-repo.ts uses Option.getOrThrow after create (line 156) and update (line 213). This throws exceptions bypassing Effect error channel. Replace with proper error handling using Effect.flatMap and Option.match or a custom NotFoundError.",
      "specs": [
        "EFFECT_SQL.md",
        "EFFECT_BEST_PRACTICES.md"
      ],
      "acceptance_criteria": [
        "packages/api/src/goals/goal-repo.ts has no Option.getOrThrow calls",
        "rg 'getOrThrow' packages/api/src/goals/ returns 0 matches",
        "Create/update return proper Effect errors if row not found",
        "bun run test:api passes (goal tests)"
      ],
      "technical_details": {
        "files": [
          "packages/api/src/goals/goal-repo.ts"
        ],
        "pattern": "Use Option.match with Effect.fail for None case, or Effect.flatMap with Option.getOrElse(() => Effect.fail(...))",
        "current_issue": "Lines 156, 213: Option.getOrThrow(result)"
      },
      "status": "pending",
      "estimated_complexity": "small"
    },
    {
      "id": "SQL-2.1",
      "phase": "Error Handling",
      "epic": "Proper Option handling",
      "title": "Replace Option.getOrThrow in settings-repo",
      "description": "settings-repo.ts uses Option.getOrThrow after upsert (line 97). Replace with proper error handling using Effect error channel.",
      "specs": [
        "EFFECT_SQL.md",
        "EFFECT_BEST_PRACTICES.md"
      ],
      "acceptance_criteria": [
        "packages/api/src/settings/settings-repo.ts has no Option.getOrThrow calls",
        "rg 'getOrThrow' packages/api/src/settings/ returns 0 matches",
        "Upsert returns proper Effect error if row not found after insert",
        "bun run test:api passes (settings tests)"
      ],
      "technical_details": {
        "files": [
          "packages/api/src/settings/settings-repo.ts"
        ],
        "pattern": "Use Option.match with Effect.fail for None case",
        "current_issue": "Line 97: Option.getOrThrow(result)"
      },
      "status": "pending",
      "estimated_complexity": "small"
    },
    {
      "id": "SQL-3.0",
      "phase": "Performance",
      "epic": "Batch operations",
      "title": "Replace loop with batch update in bulkAssignSchedule",
      "description": "injection-log-repo.ts bulkAssignSchedule (lines 258-279) uses a loop to update N rows individually. This is N+1 pattern. Additionally uses type assertion 'as unknown as { rowsAffected?: number }'. Refactor to batch operation using sql.in() or parameterized array binding.",
      "specs": [
        "EFFECT_SQL.md"
      ],
      "acceptance_criteria": [
        "bulkAssignSchedule uses single UPDATE with IN clause",
        "No 'as unknown as' type assertions",
        "rg 'as unknown as' packages/api/src/injection/ returns 0 matches",
        "bun run test:api passes (injection tests)",
        "Performance: 100 updates should be single query"
      ],
      "technical_details": {
        "files": [
          "packages/api/src/injection/injection-log-repo.ts"
        ],
        "pattern": "sql`UPDATE ... WHERE id IN ${sql.in(ids)} AND user_id = ${userId}` or use sql.unsafe with properly escaped array",
        "current_issue": "Lines 267-277: for loop + (result as unknown as { rowsAffected?: number })"
      },
      "status": "pending",
      "estimated_complexity": "medium"
    },
    {
      "id": "SQL-4.0",
      "phase": "Verification",
      "epic": "Full compliance check",
      "title": "Verify all SQL patterns comply with EFFECT_SQL.md",
      "description": "Final verification pass across all repo files. Run comprehensive grep checks, ensure no type assertions, no unsafe queries, no Option.getOrThrow, all Schema.Struct for rows.",
      "specs": [
        "EFFECT_SQL.md",
        "EFFECT_BEST_PRACTICES.md"
      ],
      "acceptance_criteria": [
        "rg '\\.unsafe\\(' packages/api/ returns 0 matches",
        "rg 'as any' packages/api/src/ returns 0 matches",
        "rg 'as unknown' packages/api/src/ returns 0 matches",
        "rg 'getOrThrow' packages/api/src/ returns 0 matches",
        "rg 'sql<' packages/api/src/ returns 0 matches (no generic type annotations)",
        "bun run check passes",
        "bun run test:all passes"
      ],
      "technical_details": {
        "files": [
          "packages/api/src/**/*-repo.ts",
          "packages/api/src/**/*-service.ts"
        ],
        "pattern": "Comprehensive grep verification of all anti-patterns"
      },
      "status": "pending",
      "estimated_complexity": "small"
    }
  ]
}
